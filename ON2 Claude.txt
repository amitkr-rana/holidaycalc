// --- CONSTANTS AND DATA SETUP (Required for the algorithm to run) ---
const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const START_DATE = new Date(2026, 0, 1); // January 1, 2026
const END_DATE = new Date(2026, 1, 28); // February 28, 2026

// Mock public holidays (PH) - Timestamps used for easy comparison
const PUBLIC_HOLIDAYS = [
    new Date(2026, 0, 20).getTime(), // Jan 20 (Tue)
    new Date(2026, 0, 17).getTime(), // Jan 17 (Sat) - Weekend PH
    new Date(2026, 1, 2).getTime(),  // Feb 2 (Mon)
    new Date(2026, 1, 14).getTime(), // Feb 14 (Sat) - Weekend PH
    new Date(2026, 1, 23).getTime(), // Feb 23 (Mon)
];

// Stores the pre-processed day objects
let CALENDAR = []; 

/**
 * Generates the calendar array with categorized days for the defined period.
 * This must be run once before the core algorithm.
 */
function generateCalendar() {
    CALENDAR = [];
    let currentDate = new Date(START_DATE);
    while (currentDate.getTime() <= END_DATE.getTime()) {
        const dayOfWeek = currentDate.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
        const isPublicHoliday = PUBLIC_HOLIDAYS.includes(currentDate.getTime());
        
        let type = 'WD'; // Work Day is default
        if (isWeekend && !isPublicHoliday) {
            type = 'W';
        } else if (isWeekend && isPublicHoliday) {
            type = 'W-PH'; // Weekend PH (no value)
        } else if (isPublicHoliday) {
            type = 'PH'; // Weekday PH (valuable)
        }

        // Fix: Use year-month key to avoid collisions across years
        const monthKey = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

        CALENDAR.push({
            date: new Date(currentDate),
            type: type, // WD, W, PH, or W-PH
            monthKey: monthKey,
            monthName: MONTH_NAMES[currentDate.getMonth()],
            timestamp: currentDate.getTime()
        });

        currentDate.setDate(currentDate.getDate() + 1);
    }
}


/**
 * Core algorithm to find holiday chains based on mode and constraints.
 * @param {string} mode - 'optimal' (maximize length, minimize leaves) or 'user-total' (maximize length using exactly X leaves).
 * @param {number} X - Total leaves to use (mandatory for 'user-total' mode). Ignored for 'optimal' mode.
 * @param {number} maxPolicy - Max leaves per month for all chains.
 * @returns {object} { MaxChainLength: number, MinTotalLeaves: number, BestChainsFound: Array<{start: Date, end: Date, length: number, leaves: number}> }
 */
function calculateHolidayChains(mode, X, maxPolicy) {
    if (CALENDAR.length === 0) return { MaxChainLength: 0, MinTotalLeaves: 0, BestChainsFound: [] };

    let MaxChainLength = 0;
    let MinTotalLeaves = -1; 
    const N = CALENDAR.length;
    
    // Use Map for better duplicate tracking
    const seenChains = new Map();

    // --- USER-BASED (TOTAL LEAVES) MODE LOGIC ---
    if (mode === 'user-total') {
        const totalWorkDays = CALENDAR.filter(d => d.type === 'WD').length;
        
        // Fix: Better validation with reasonable upper limit
        if (X < 1) {
            console.warn(`User-Total Mode: Invalid leaves count (${X}). Must be at least 1.`);
            return { MaxChainLength: 0, MinTotalLeaves: 0, BestChainsFound: [] };
        }
        if (X > totalWorkDays) {
            console.warn(`User-Total Mode: Leaves count (${X}) exceeds total work days (${totalWorkDays}).`);
            return { MaxChainLength: 0, MinTotalLeaves: 0, BestChainsFound: [] };
        }
        if (X > 15) {
            console.warn(`User-Total Mode: Leaves count (${X}) exceeds practical limit of 15 for this period.`);
            return { MaxChainLength: 0, MinTotalLeaves: 0, BestChainsFound: [] };
        }

        MinTotalLeaves = X;

        for (let S = 0; S < N; S++) {
            let LeavesByMonth = {};
            let HasWeekdayPublicHoliday = false; // Fix: Only count weekday PHs
            let CurrentLeavesUsed = 0;
            
            for (let E = S; E < N; E++) {
                const D = CALENDAR[E];
                
                if (D.type === 'WD') {
                    const monthKey = D.monthKey;
                    LeavesByMonth[monthKey] = (LeavesByMonth[monthKey] || 0) + 1;
                    CurrentLeavesUsed++;
                }
                if (D.type === 'PH') HasWeekdayPublicHoliday = true; // Fix: Only weekday PH counts

                // Fix: Enforce policy limit in user-total mode
                const MaxLeavesInAnyMonth = Object.values(LeavesByMonth).reduce((max, val) => Math.max(max, val), 0);
                if (MaxLeavesInAnyMonth > maxPolicy) break;

                if (CurrentLeavesUsed > X) break; // Optimization: stop if we exceed X

                if (HasWeekdayPublicHoliday && CurrentLeavesUsed === X) {
                    
                    const monthKeys = Object.keys(LeavesByMonth);
                    const numMonths = monthKeys.length;
                    
                    // Constraint: Odd X spanning exactly 2 months MUST be 1 and X-1 split (KEPT as requested)
                    if (X % 2 !== 0 && numMonths === 2) {
                        const L1 = LeavesByMonth[monthKeys[0]];
                        const L2 = LeavesByMonth[monthKeys[1]];
                        const isUnevenSplit = (L1 === 1 && L2 === X - 1) || (L1 === X - 1 && L2 === 1);
                        if (!isUnevenSplit) continue; 
                    }
                    
                    const CurrentLength = E - S + 1;
                    const chainKey = `${CALENDAR[S].timestamp}-${CALENDAR[E].timestamp}`;

                    // Tie-breaking: Maximize Length
                    if (CurrentLength >= MaxChainLength) {
                        if (CurrentLength > MaxChainLength) {
                            seenChains.clear();
                            MaxChainLength = CurrentLength;
                        }
                        
                        // Fix: Check for duplicates immediately
                        if (!seenChains.has(chainKey)) {
                            seenChains.set(chainKey, { 
                                start: CALENDAR[S].date, 
                                end: CALENDAR[E].date, 
                                length: CurrentLength, 
                                leaves: X 
                            });
                        }
                    }
                }
            }
        }
        return { MaxChainLength, MinTotalLeaves: X, BestChainsFound: Array.from(seenChains.values()) };
    }

    // --- OPTIMAL MODE LOGIC (MAX LENGTH, MIN LEAVES) ---
    else { // mode === 'optimal'
        for (let S = 0; S < N; S++) {
            let LeavesByMonth = {};
            let HasWeekdayPublicHoliday = false; // Fix: Only count weekday PHs

            for (let E = S; E < N; E++) {
                const D = CALENDAR[E];
                
                if (D.type === 'WD') {
                    const monthKey = D.monthKey;
                    LeavesByMonth[monthKey] = (LeavesByMonth[monthKey] || 0) + 1;
                }
                if (D.type === 'PH') HasWeekdayPublicHoliday = true; // Fix: Only weekday PH counts

                // Fix: Apply consistent policy limit across all chains
                const MaxLeavesInAnyMonth = Object.values(LeavesByMonth).reduce((max, val) => Math.max(max, val), 0);
                if (MaxLeavesInAnyMonth > maxPolicy) break;
                
                const TotalLeaves = Object.values(LeavesByMonth).reduce((sum, val) => sum + val, 0);

                if (HasWeekdayPublicHoliday) {
                    const CurrentLength = E - S + 1;
                    const chainKey = `${CALENDAR[S].timestamp}-${CALENDAR[E].timestamp}`;

                    // Tie-breaking: Length (maximized) > Leaves (minimized)
                    if (CurrentLength > MaxChainLength) {
                        seenChains.clear();
                        MaxChainLength = CurrentLength;
                        MinTotalLeaves = TotalLeaves;
                        seenChains.set(chainKey, { 
                            start: CALENDAR[S].date, 
                            end: CALENDAR[E].date, 
                            length: CurrentLength, 
                            leaves: TotalLeaves 
                        });
                    } else if (CurrentLength === MaxChainLength) {
                        if (MinTotalLeaves === -1 || TotalLeaves < MinTotalLeaves) {
                            seenChains.clear();
                            MinTotalLeaves = TotalLeaves;
                            seenChains.set(chainKey, { 
                                start: CALENDAR[S].date, 
                                end: CALENDAR[E].date, 
                                length: CurrentLength, 
                                leaves: TotalLeaves 
                            });
                        } else if (TotalLeaves === MinTotalLeaves) {
                            // Fix: Check for duplicates immediately
                            if (!seenChains.has(chainKey)) {
                                seenChains.set(chainKey, { 
                                    start: CALENDAR[S].date, 
                                    end: CALENDAR[E].date, 
                                    length: CurrentLength, 
                                    leaves: TotalLeaves 
                                });
                            }
                        }
                    }
                }
            }
        }
        
        return { MaxChainLength, MinTotalLeaves, BestChainsFound: Array.from(seenChains.values()) };
    }
}


// --- EXPORTED FUNCTION (The API you requested) ---

/**
 * Calculates the array of optimal holiday chain possibilities based on the given mode.
 * @param {string} mode - 'optimal' (Max Length, Min Leaves) or 'user-total' (Exactly X Leaves).
 * @param {number} X - Number of leaves to use. Ignored in 'optimal' mode.
 * @returns {Array<{start: Date, end: Date, length: number, leaves: number}>} - Array of the best chain possibilities found.
 */
function calculateHolidayChainsAlgorithm(mode, X) {
    
    // 1. Setup the Calendar data structure (must be done before calculation)
    generateCalendar();
    
    let maxPolicy = 2; // Max policy applies to ALL chains now
    
    // 2. Call the core logic
    const results = calculateHolidayChains(mode, X, maxPolicy);
    
    // 3. Return only the array of best chains (the possibilities)
    return results.BestChainsFound;
}

// Example usage and testing:
console.log('=== FIXED ALGORITHM TESTS ===\n');

// 1. Optimal Mode (Max Length, Min Leaves, Max 2 leaves per month)
const optimalChains = calculateHolidayChainsAlgorithm('optimal'); 
console.log('--- Optimal Mode (Max Policy 2) ---');
console.log('Results:', optimalChains);
console.log('Note: Weekend PHs (Jan 17, Feb 14) should NOT create valid chains by themselves\n');

// 2. User-Total Mode (Exactly 4 Leaves) - with policy enforcement
const userTotalChains = calculateHolidayChainsAlgorithm('user-total', 4);
console.log('--- User-Total Mode (Exactly 4 Leaves) ---');
console.log('Results:', userTotalChains);
console.log('Note: Policy limit of 2 leaves/month is now enforced\n');

// 3. Test weekend PH detection
console.log('--- Calendar Analysis ---');
const weekendPHs = CALENDAR.filter(d => d.type === 'W-PH');
const weekdayPHs = CALENDAR.filter(d => d.type === 'PH');
console.log('Weekend PHs (no value):', weekendPHs.map(d => d.date.toDateString()));
console.log('Weekday PHs (valuable):', weekdayPHs.map(d => d.date.toDateString()));